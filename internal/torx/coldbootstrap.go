package torx

import (
	"context"
	"os"
	"sync"
	"time"

	"github.com/ooni/probe-cli/v3/internal/model"
)

// ColdBootstrapSession is [RunColdBootstrap] view of a measurement session.
type ColdBootstrapSession interface {
	TempDir() string
}

// ColdBootstrapResult is the result of [RunColdBootstrap].
type ColdBootstrapResult struct {
	// DataDir is the temporary data directory.
	DataDir *DataDirState

	// Proc is the tor process.
	Proc Process

	// Conn is the process-owning control connection.
	Conn *ControlConn

	// Events contains the Events generated by the bootstrap.
	Events []string

	// Elapsed is the total time spent attempting to bootstrap.
	Elapsed time.Duration

	// error is the error occurred during the bootstrap.
	Err error

	// once ensures close runs just once.
	once *sync.Once
}

// Close releases the resources allocated during the bootstrap.
func (cbr *ColdBootstrapResult) Close() error {
	cbr.once.Do(func() {
		// first close the control conn
		_ = cbr.Conn.Close()

		// then wait for the process to terminate
		done := make(chan any)
		go func() {
			defer close(done)
			_, _ = cbr.Proc.Wait()
		}()

		// make sure we don't wait too much
		const maxwait = 500 * time.Millisecond
		select {
		case <-time.After(maxwait):
			// kill and then wait again for termination
			_ = cbr.Proc.Kill()
			<-done

		case <-done:
			// all good
		}

		// finally, let's wipe the datadir
		_ = cbr.DataDir.Close()
	})
	return nil
}

// RunColdBootstrap performs a botstrap using an empty data dir.
func RunColdBootstrap(
	ctx context.Context,
	dirs ColdBootstrapSession,
	logger model.Logger,
	options ...ExecOption,
) (*ColdBootstrapResult, error) {
	// make sure the temporary directory exists
	if err := os.MkdirAll(dirs.TempDir(), 0700); err != nil {
		return nil, err
	}

	// create temporary directory
	tempdir, err := os.MkdirTemp(dirs.TempDir(), "tor-*")
	if err != nil {
		return nil, err
	}

	// open the data directory
	datadir, err := NewDataDirState(tempdir, DataDirOptionRemoveDataDir(true))
	if err != nil {
		return nil, err
	}

	// execute the process
	proc, err := Exec(datadir, logger, options...)
	if err != nil {
		_ = datadir.Close()
		return nil, err
	}

	// dial a control connection
	conn, err := proc.DialControl(ctx)
	if err != nil {
		_ = proc.Kill()
		_, _ = proc.Wait()
		_ = datadir.Close()
		return nil, err
	}

	// authenticate
	if err := AuthenticateFlowWithSafeCookie(ctx, conn); err != nil {
		_ = proc.Kill()
		_, _ = proc.Wait()
		_ = datadir.Close()
		return nil, err
	}

	// take ownership of the conn
	if err := TakeOwnership(ctx, conn); err != nil {
		_ = proc.Kill()
		_, _ = proc.Wait()
		_ = datadir.Close()
		return nil, err
	}

	// bootstrap and record the bootstrap result
	started := time.Now()
	events, err := Bootstrap(ctx, conn)
	elapsed := time.Since(started)

	// return the results
	results := &ColdBootstrapResult{
		DataDir: datadir,
		Proc:    proc,
		Conn:    conn,
		Events:  events,
		Elapsed: elapsed,
		Err:     err,
		once:    &sync.Once{},
	}
	return results, nil
}
