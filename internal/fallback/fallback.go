// Package fallback contains code for falling back to different
// producers to generate a specific result.
package fallback

import (
	"context"
	"errors"

	"github.com/ooni/probe-cli/v3/internal/multierror"
)

// Producer is something that produces a Result from a given Config.
type Producer[Config, Result any] interface {
	// Produce produces a Result from a given Config.
	Produce(ctx context.Context, config Config) (Result, error)

	// URL is the unique URL of the producer.
	URL() string
}

// Director coordinates the execution of multiple, possibly-overlapped [Producer]
// instances and the recording of which [Producer] instances worked.
type Director interface {
	// Acquire returns the channel controlling when a [Producer] could start.
	Acquire() <-chan any

	// Errored informs the [Director] that a [Producer] returned an error.
	Errored(URL string, err error)

	// Canceled informs the [Director] that a [Producer] execution was canceled.
	Canceled(URL string)

	// Release informs the [Director] that a [Producer] has terminated.
	Release()

	// Succeeded informs the [Director] that a [Producer] succeded.
	Succeeded(URL string)
}

// errorOr contains either an error or a Result.
type errorOr[Result any] struct {
	// err is the error
	err error

	// result is the Result
	result Result
}

// ErrAllProducersFailed indicates that all producers failed.
var ErrAllProducersFailed = errors.New("fallback: all producers failed")

// Run invokes all producers with the given config and returns either the Result
// generated by the successful producer or an error.
//
// Arguments:
//
// - ctx allows to interrupt the operation early;
//
// - director controls the execution and records the execution status;
//
// - config is the configuration for the producers;
//
// - producers is the list of producers.
//
// In case of failure, the returned error is a [multierror.Union] whose
// base error is the [ErrAllProducersFailed] error.
func Run[Config, Result any](
	ctx context.Context,
	director Director,
	config Config,
	producers ...Producer[Config, Result],
) (Result, error) {
	// create cancellable context to interrupt background goroutines
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	// create channel for collecting results
	outch := make(chan *errorOr[Result], len(producers))

	// spawn goroutines in parallel
	for _, p := range producers {
		go func(p Producer[Config, Result]) {
			// await for permission to start running
			<-director.Acquire()

			// let the Director know this goroutine completed
			defer director.Release()

			// produce a Result
			result, err := p.Produce(ctx, config)

			// handle the case of context cancellation
			if errors.Is(ctx.Err(), context.Canceled) {
				outch <- &errorOr[Result]{err: ctx.Err()}
				director.Canceled(p.URL())
				return
			}

			// handle the case of failure
			if err != nil {
				outch <- &errorOr[Result]{err: err}
				director.Errored(p.URL(), err)
				return
			}

			// interrupt other goroutines that may be running
			cancel()

			// emit successful response
			outch <- &errorOr[Result]{result: result}
			director.Succeeded(p.URL())
		}(p)
	}

	// collect the results of all producers
	outv := []*errorOr[Result]{}
	for len(outv) < len(producers) {
		outv = append(outv, <-outch)
	}

	// return either a multierror or a result to the caller
	me := multierror.New(ErrAllProducersFailed)
	for _, out := range outv {
		if out.err != nil {
			me.Add(out.err)
			continue
		}
		return out.result, nil
	}
	zerov := *new(Result) // zero value
	return zerov, me
}
